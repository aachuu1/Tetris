#include <ncurses.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h> 

#define ROWS 20
#define COLS 10
#define EMPTY 0

#define BASE_DELAY 500000  
#define SOFT_DROP_DELAY 50000

static const int pieces[7][4][4][4] = {
    // I
    {
        {
            {0,0,0,0},
            {1,1,1,1},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,0,1,0},
            {0,0,1,0},
            {0,0,1,0},
            {0,0,1,0}
        },
        {
            {0,0,0,0},
            {0,0,0,0},
            {1,1,1,1},
            {0,0,0,0}
        },
        {
            {0,1,0,0},
            {0,1,0,0},
            {0,1,0,0},
            {0,1,0,0}
        }
    },
    // J
    {
        {
            {1,0,0,0},
            {1,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,1,1,0},
            {0,1,0,0},
            {0,1,0,0},
            {0,0,0,0}
        },
        {
            {0,0,0,0},
            {1,1,1,0},
            {0,0,1,0},
            {0,0,0,0}
        },
        {
            {0,1,0,0},
            {0,1,0,0},
            {1,1,0,0},
            {0,0,0,0}
        }
    },
    // L
    {
        {
            {0,0,1,0},
            {1,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,1,0,0},
            {0,1,0,0},
            {0,1,1,0},
            {0,0,0,0}
        },
        {
            {0,0,0,0},
            {1,1,1,0},
            {1,0,0,0},
            {0,0,0,0}
        },
        {
            {1,1,0,0},
            {0,1,0,0},
            {0,1,0,0},
            {0,0,0,0}
        }
    },
    // O
    {
        {
            {0,1,1,0},
            {0,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,1,1,0},
            {0,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,1,1,0},
            {0,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,1,1,0},
            {0,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        }
    },
    // S
    {
        {
            {0,1,1,0},
            {1,1,0,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,1,0,0},
            {0,1,1,0},
            {0,0,1,0},
            {0,0,0,0}
        },
        {
            {0,0,0,0},
            {0,1,1,0},
            {1,1,0,0},
            {0,0,0,0}
        },
        {
            {1,0,0,0},
            {1,1,0,0},
            {0,1,0,0},
            {0,0,0,0}
        }
    },
    // T
    {
        {
            {0,1,0,0},
            {1,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,1,0,0},
            {0,1,1,0},
            {0,1,0,0},
            {0,0,0,0}
        },
        {
            {0,0,0,0},
            {1,1,1,0},
            {0,1,0,0},
            {0,0,0,0}
        },
        {
            {0,1,0,0},
            {1,1,0,0},
            {0,1,0,0},
            {0,0,0,0}
        }
    },
    // Z
    {
        {
            {1,1,0,0},
            {0,1,1,0},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,0,1,0},
            {0,1,1,0},
            {0,1,0,0},
            {0,0,0,0}
        },
        {
            {0,0,0,0},
            {1,1,0,0},
            {0,1,1,0},
            {0,0,0,0}
        },
        {
            {0,1,0,0},
            {1,1,0,0},
            {1,0,0,0},
            {0,0,0,0}
        }
    }
};

typedef struct {
    int type;   
    int rot;   
    int row;   
    int col;    
} Piece;

int field[ROWS][COLS];
Piece cur;
Piece nextPiece;
int score = 0;
int gameOver = 0;

void init_game();
void draw();
int collides(const Piece *p);
void place_piece(const Piece *p, int val);
void spawn_piece(Piece *p);
void rotate_piece(Piece *p);
void fix_piece();
int clear_lines();
int try_move(Piece *p, int dr, int dc, int drot);
void copy_piece(Piece *dst, const Piece *src);
void draw_border();
void draw_info();

int main() {
    srand(time(NULL));
    initscr();
    noecho();
    cbreak();
    curs_set(0);
    keypad(stdscr, TRUE);
    nodelay(stdscr, TRUE);
    start_color();

    init_pair(1, COLOR_CYAN, COLOR_BLACK);   // I
    init_pair(2, COLOR_BLUE, COLOR_BLACK);   // J
    init_pair(3, COLOR_YELLOW, COLOR_BLACK); // L 
    init_pair(4, COLOR_MAGENTA, COLOR_BLACK);// O
    init_pair(5, COLOR_GREEN, COLOR_BLACK);  // S
    init_pair(6, COLOR_RED, COLOR_BLACK);    // T
    init_pair(7, COLOR_WHITE, COLOR_BLACK);  // Z
    init_pair(8, COLOR_WHITE, COLOR_BLACK);  // text

    init_game();
    unsigned int delay = BASE_DELAY;
    unsigned long last_tick = 0;
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    last_tick = ts.tv_sec * 1000000 + ts.tv_nsec / 1000;

    int ch;
    int softDrop = 0;

    while (!gameOver) {
        clock_gettime(CLOCK_MONOTONIC, &ts);
        unsigned long now = ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
        unsigned long elapsed = now - last_tick;

        ch = getch();
        if (ch != ERR) {
            if (ch == 'q' || ch == 'Q') break;
            else if (ch == ' ') {
                // hard drop
                while (try_move(&cur, 1, 0, 0)) {
                    cur.row++;
                }
                fix_piece();
                last_tick = now;
            } else if (ch == KEY_LEFT) {
                try_move(&cur, 0, -1, 0);
            } else if (ch == KEY_RIGHT) {
                try_move(&cur, 0, 1, 0);
            } else if (ch == KEY_DOWN) {
                // soft drop
                softDrop = 1;
            } else if (ch == KEY_UP || ch == 'z' || ch == 'Z' || ch == 'x' || ch == 'X') {
                Piece tmp;
                copy_piece(&tmp, &cur);
                tmp.rot = (tmp.rot + 1) & 3;
                if (!collides(&tmp)) {
                    cur.rot = tmp.rot;
                } else {
                    tmp.col = cur.col - 1;
                    if (!collides(&tmp)) cur.col--;
                    else {
                        tmp.col = cur.col + 1;
                        if (!collides(&tmp)) cur.col++;
                    }
                }
            }
        } else {
            softDrop = 0;
        }

        unsigned int cur_delay = softDrop ? SOFT_DROP_DELAY : delay;

        if (elapsed >= cur_delay) {
            if (try_move(&cur, 1, 0, 0)) {
                cur.row++;
            } else {
                fix_piece();
            }
            last_tick = now;
        }

        draw();
        usleep(1000); // mic sleep pentru CPU
    }

    clear();
    mvprintw(ROWS/2, COLS + 5, "GAME OVER");
    mvprintw(ROWS/2 + 1, COLS + 5, "Scor: %d", score);
    mvprintw(ROWS/2 + 3, COLS + 5, "Apasa orice tasta...");
    nodelay(stdscr, FALSE);
    getch();

    endwin();
    return 0;
}

void init_game() {
    memset(field, 0, sizeof(field));
    score = 0;
    gameOver = 0;

    // spawn curent si next
    spawn_piece(&nextPiece);
    spawn_piece(&cur);
    // plasăm cur la mijloc sus
    cur.row = 0;
    cur.col = (COLS / 2) - 2;
    // daca initial coliziune -> game over
    if (collides(&cur)) gameOver = 1;
}

void spawn_piece(Piece *p) {
    p->type = rand() % 7;
    p->rot = 0;
    p->row = 0;
    p->col = (COLS / 2) - 2;
}

// copie simplă
void copy_piece(Piece *dst, const Piece *src) {
    dst->type = src->type;
    dst->rot = src->rot;
    dst->row = src->row;
    dst->col = src->col;
}

int collides(const Piece *p) {
    int t = p->type;
    int r = p->rot;
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (pieces[t][r][i][j]) {
                int fr = p->row + i;
                int fc = p->col + j;
                if (fc < 0 || fc >= COLS || fr >= ROWS) return 1;
                if (fr >= 0) { // celulele negative peste partea de sus sunt permise
                    if (field[fr][fc]) return 1;
                }
            }
        }
    }
    return 0;
}

// incearcă mutare; returnează 1 dacă mutarea este posibilă (nu aplică modificarea)
// dr, dc, drot - aplicate pe un copy
int try_move(Piece *p, int dr, int dc, int drot) {
    Piece tmp;
    copy_piece(&tmp, p);
    tmp.row += dr;
    tmp.col += dc;
    if (drot) tmp.rot = (tmp.rot + drot) & 3;
    if (!collides(&tmp)) {
        // aplică modificarea
        p->row = tmp.row;
        p->col = tmp.col;
        p->rot = tmp.rot;
        return 1;
    }
    return 0;
}

void place_piece(const Piece *p, int val) {
    int t = p->type;
    int r = p->rot;
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (pieces[t][r][i][j]) {
                int fr = p->row + i;
                int fc = p->col + j;
                if (fr >= 0 && fr < ROWS && fc >= 0 && fc < COLS) {
                    field[fr][fc] = val;
                }
            }
        }
    }
}

void fix_piece() {
    // scrie in field cu valoarea piesei+1 (pentru color)
    place_piece(&cur, cur.type + 1);
    // sterge linii
    int cleared = clear_lines();
    if (cleared > 0) {
        score += (cleared * 100);
    }
    // spawn next: cur = next, next=random
    copy_piece(&cur, &nextPiece);
    spawn_piece(&nextPiece);
    // reset pozitie initiala cur
    cur.row = 0;
    cur.col = (COLS / 2) - 2;
    cur.rot = 0;
    // daca coliziune dupa spawn -> game over
    if (collides(&cur)) gameOver = 1;
}

int clear_lines() {
    int cleared = 0;
    for (int r = ROWS-1; r >= 0; --r) {
        int full = 1;
        for (int c = 0; c < COLS; ++c) {
            if (field[r][c] == EMPTY) { full = 0; break; }
        }
        if (full) {
            // muta totul deasupra cu o linie jos
            for (int rr = r; rr > 0; --rr) {
                for (int cc = 0; cc < COLS; ++cc) field[rr][cc] = field[rr-1][cc];
            }
            // top empty
            for (int cc = 0; cc < COLS; ++cc) field[0][cc] = EMPTY;
            cleared++;
            // verificam din nou aceeasi linie (deoarece s-au coborat)
            r++; // cand se decrementeaza in for, se revine la aceeasi index
        }
    }
    return cleared;
}

void draw_border() {
    // desenam o caseta pentru field
    int offset_col = 2;
    int offset_row = 1;
    attron(COLOR_PAIR(8));
    for (int r = 0; r <= ROWS+1; ++r) {
        mvprintw(offset_row + r - 1, offset_col - 2, "|");
        mvprintw(offset_row + r - 1, offset_col + COLS*2, "|");
    }
    for (int c = 0; c <= COLS*2; ++c) {
        mvprintw(offset_row + ROWS, offset_col - 1 + c, "-");
    }
    attroff(COLOR_PAIR(8));
}

void draw_info() {
    int offc = COLS*2 + 6;
    mvprintw(1, offc, "TETRIS ncurses");
    mvprintw(3, offc, "Scor: %d", score);
    mvprintw(5, offc, "Controale:");
    mvprintw(6, offc, "Sageti: miscari");
    mvprintw(7, offc, "Up / Z/X: rotire");
    mvprintw(8, offc, "Down: soft drop");
    mvprintw(9, offc, "Space: hard drop");
    mvprintw(10, offc, "Q: quit");
    mvprintw(12, offc, "Next:");
    // desenare nextPiece
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            int v = pieces[nextPiece.type][nextPiece.rot][i][j];
            if (v) {
                attron(COLOR_PAIR(nextPiece.type + 1));
                mvprintw(14 + i, offc + j*2, "[]");
                attroff(COLOR_PAIR(nextPiece.type + 1));
            } else {
                mvprintw(14 + i, offc + j*2, "  ");
            }
        }
    }
}

void draw() {
    clear();
    int offset_col = 2;
    int offset_row = 1;

    // desenam field
    for (int r = 0; r < ROWS; ++r) {
        for (int c = 0; c < COLS; ++c) {
            int val = field[r][c];
            if (val) {
                int color = val;
                attron(COLOR_PAIR(color));
                mvprintw(offset_row + r, offset_col + c*2, "[]");
                attroff(COLOR_PAIR(color));
            } else {
                mvprintw(offset_row + r, offset_col + c*2, "  ");
            }
        }
    }

    // desenam piesa curenta (suprapusa)
    int t = cur.type;
    int r0 = cur.rot;
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (pieces[t][r0][i][j]) {
                int fr = cur.row + i;
                int fc = cur.col + j;
                if (fr >= 0 && fr < ROWS && fc >= 0 && fc < COLS) {
                    attron(COLOR_PAIR(t + 1) | A_BOLD);
                    mvprintw(offset_row + fr, offset_col + fc*2, "[]");
                    attroff(COLOR_PAIR(t + 1) | A_BOLD);
                }
            }
        }
    }

    draw_border();
    draw_info();

    refresh();
}

